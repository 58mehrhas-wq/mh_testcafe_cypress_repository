"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformCheckSettings = exports.transformConfig = exports.LegacyTestCafeEyesMixin = void 0;
const utils = require("@applitools/utils");
const api = require("@applitools/eyes-api");
const fs = require("fs");
const path = require("path");
const spec = require("./spec-driver");
const eyes_sdk_core_1 = require("@applitools/eyes-sdk-core");
function LegacyTestCafeEyesMixin(Eyes) {
    return class TestCafeEyes extends Eyes {
        constructor(runnerOrConfigOrOptions, configOrRunner) {
            var _a, _b, _c;
            if (utils.types.isNull(runnerOrConfigOrOptions) || utils.types.has(runnerOrConfigOrOptions, 'configPath')) {
                const testcafeConfig = utils.config.getConfig({
                    paths: (runnerOrConfigOrOptions === null || runnerOrConfigOrOptions === void 0 ? void 0 : runnerOrConfigOrOptions.configPath) && [runnerOrConfigOrOptions.configPath],
                    params: ['failTestcafeOnDiff'],
                });
                const runner = (_a = runnerOrConfigOrOptions === null || runnerOrConfigOrOptions === void 0 ? void 0 : runnerOrConfigOrOptions.runner) !== null && _a !== void 0 ? _a : new api.VisualGridRunner({ testConcurrency: (_c = (_b = testcafeConfig.concurrency) !== null && _b !== void 0 ? _b : testcafeConfig.testConcurrency) !== null && _c !== void 0 ? _c : 1 });
                super(runner, transformConfig(testcafeConfig));
                this._testcafeConfig = testcafeConfig;
            }
            else {
                super(runnerOrConfigOrOptions, configOrRunner);
            }
        }
        async open(driverOrOptions, configOrAppName, testName, viewportSize, sessionType) {
            let driver, config;
            if (utils.types.has(driverOrOptions, 't')) {
                const { t, ...testcafeConfig } = driverOrOptions;
                this._testcafeConfig = { ...this._testcafeConfig, ...testcafeConfig };
                driver = t;
                config = transformConfig(this._testcafeConfig);
            }
            else {
                driver = driverOrOptions;
                config = configOrAppName;
            }
            await spec
                .executeScript(driver, () => true)
                .catch(() => {
                throw new Error(`The browser is in an invalid state due to JS errors on the page that TestCafe is unable to handle. Try running the test with TestCafe's --skip-js-errors option enabled: https://devexpress.github.io/testcafe/documentation/reference/configuration-file.html#skipjserrors`);
            });
            return super.open(driver, config, testName, viewportSize, sessionType);
        }
        async checkWindow(nameOrSetting, timeout, fully = true) {
            if (utils.types.isObject(nameOrSetting)) {
                return super.check(transformCheckSettings(nameOrSetting));
            }
            return super.checkWindow(nameOrSetting, timeout, fully);
        }
        async close(throwErr = true) {
            var _a, _b;
            return super.close(throwErr && ((_b = (_a = this._testcafeConfig) === null || _a === void 0 ? void 0 : _a.failTestcafeOnDiff) !== null && _b !== void 0 ? _b : true));
        }
        async waitForResults(throwErr = true) {
            var _a, _b, _c;
            const resultsSummary = await this.runner.getAllTestResults(throwErr && ((_b = (_a = this._testcafeConfig) === null || _a === void 0 ? void 0 : _a.failTestcafeOnDiff) !== null && _b !== void 0 ? _b : true));
            if ((_c = this._testcafeConfig) === null || _c === void 0 ? void 0 : _c.tapDirPath) {
                const results = resultsSummary.getAllResults().map(r => r.getTestResults());
                const includeSubTests = false;
                const markNewAsPassed = true;
                const formatted = new eyes_sdk_core_1.TestResultsFormatter(results).asHierarchicTAPString(includeSubTests, markNewAsPassed);
                fs.writeFileSync(path.resolve(this._testcafeConfig.tapDirPath, 'eyes.tap'), formatted);
            }
            return resultsSummary;
        }
    };
}
exports.LegacyTestCafeEyesMixin = LegacyTestCafeEyesMixin;
function transformConfig(options) {
    const config = { ...options };
    if (options.concurrency)
        config.concurrentSessions = options.concurrency;
    if (options.envName)
        config.environmentName = options.envName;
    if (options.browser)
        config.browsersInfo = utils.types.isArray(options.browser) ? options.browser : [options.browser];
    if (options.batchId ||
        options.batchName ||
        options.notifyOnCompletion ||
        process.env.APPLITOOLS_NOTIFY_ON_COMPLETION) {
        config.batch = {
            id: options.batchId,
            name: options.batchName,
            notifyOnCompletion: options.notifyOnCompletion || !!process.env.APPLITOOLS_NOTIFY_ON_COMPLETION,
        };
    }
    if (options.matchLevel || options.ignoreCaret || options.ignoreDisplacements || options.accessibilityValidation) {
        config.defaultMatchSettings = {
            ignoreCaret: options.ignoreCaret,
            matchLevel: options.matchLevel,
            ignoreDisplacements: options.ignoreDisplacements,
            accessibilitySettings: options.accessibilityValidation,
        };
    }
    if (utils.types.isString(options.proxy))
        config.proxy = { url: options.proxy };
    if (options.showLogs)
        config.logs = { type: 'console' };
    return config;
}
exports.transformConfig = transformConfig;
function transformCheckSettings(options) {
    var _a;
    const settings = { ...options };
    settings.name = options.tag;
    settings.hooks = options.scriptHooks;
    settings.fully = (_a = options.fully) !== null && _a !== void 0 ? _a : options.target !== 'region';
    if (options.target && options.target === 'region' && options.selector) {
        settings.region = options.selector;
    }
    if (options.accessibility) {
        const accessibilityRegions = utils.types.isArray(options.accessibility)
            ? options.accessibility
            : [options.accessibility];
        settings.accessibilityRegions = accessibilityRegions.map(accessibilityRegion => {
            const { accessibilityType, ...region } = accessibilityRegion;
            if (utils.types.has(region, 'selector') && !utils.types.has(region, 'type')) {
                return { region: region.selector, accessibilityType };
            }
            else {
                return { region, accessibilityType };
            }
        });
    }
    if (options.floating) {
        const floatingRegions = utils.types.isArray(options.floating) ? options.floating : [options.floating];
        settings.floatingRegions = floatingRegions.map(floatingRegion => {
            const { maxUpOffset, maxDownOffset, maxLeftOffset, maxRightOffset, ...region } = floatingRegion;
            if (utils.types.has(region, 'selector') && !utils.types.has(region, 'type')) {
                return { maxUpOffset, maxDownOffset, maxLeftOffset, maxRightOffset, region: region.selector };
            }
            else {
                return { maxUpOffset, maxDownOffset, maxLeftOffset, maxRightOffset, region };
            }
        });
    }
    if (options.ignore) {
        const ignoreRegions = utils.types.isArray(options.ignore) ? options.ignore : [options.ignore];
        settings.ignoreRegions = ignoreRegions.map(region => {
            if (utils.types.has(region, 'selector') && !utils.types.has(region, 'type')) {
                return region.selector;
            }
            else {
                return region;
            }
        });
    }
    if (options.layout) {
        const layoutRegions = utils.types.isArray(options.layout) ? options.layout : [options.layout];
        settings.layoutRegions = layoutRegions.map(region => {
            if (utils.types.has(region, 'selector') && !utils.types.has(region, 'type')) {
                return region.selector;
            }
            else {
                return region;
            }
        });
    }
    if (options.strict) {
        const strictRegions = utils.types.isArray(options.strict) ? options.strict : [options.strict];
        settings.strictRegions = strictRegions.map(region => {
            if (utils.types.has(region, 'selector') && !utils.types.has(region, 'type')) {
                return region.selector;
            }
            else {
                return region;
            }
        });
    }
    if (options.content) {
        const contentRegions = utils.types.isArray(options.content) ? options.content : [options.content];
        settings.contentRegions = contentRegions.map(region => {
            if (utils.types.has(region, 'selector') && !utils.types.has(region, 'type')) {
                return region.selector;
            }
            else {
                return region;
            }
        });
    }
    return settings;
}
exports.transformCheckSettings = transformCheckSettings;
